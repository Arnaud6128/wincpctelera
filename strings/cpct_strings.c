//-----------------------------LICENSE NOTICE------------------------------------
//  This file is part of CPCtelera: An Amstrad CPC Game Engine
//  Copyright (C) 2019 Arnaud Bouche
//  Copyright (C) 2019 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------------

#include "winCpctelera.h"

extern u8* wincpct_getVideoBufferFromAddress(void* pScreenAddr);
extern u16 wincpct_getCpcMemAddress(void* address);
extern u8* wincpct_getPCMemPtr(u16 address);
extern void wincpct_computeCrossBoundary(u16* videoAddress, u8 cx);

#define FONT_SIZE		8
#define FONT_NB_LINE	32
#define FONT_NB_COL		3
#define FONT_COL		(FONT_NB_COL*FONT_SIZE)

/** Bottom - Top */
static const u8 sFonts[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x80,
	0x3B, 0x6E, 0x1E, 0x3B, 0x1E, 0x3C, 0x03, 0x73, 0x1E, 0x33, 0x73, 0x1E, 0x63, 0x33, 0x1E, 0x30, 0x06, 0x78, 0x3E, 0x0E, 0x1F, 0x0C, 0x36, 0x63, 0x03, 0x3F, 0x07, 0x0C, 0x38, 0x00, 0x66, 0x00,
	0x66, 0x33, 0x33, 0x66, 0x30, 0x18, 0x1F, 0x33, 0x0C, 0x33, 0x36, 0x0C, 0x6B, 0x33, 0x33, 0x3E, 0x3E, 0x30, 0x03, 0x1B, 0x33, 0x1E, 0x7F, 0x36, 0x1F, 0x19, 0x0C, 0x0C, 0x0C, 0x00, 0x19, 0x80,
	0x3E, 0x33, 0x30, 0x66, 0x3F, 0x18, 0x33, 0x33, 0x0C, 0x03, 0x3C, 0x0C, 0x6B, 0x33, 0x33, 0x33, 0x66, 0x30, 0x1E, 0x18, 0x33, 0x33, 0x6B, 0x1C, 0x33, 0x0C, 0x0C, 0x0C, 0x0C, 0x00, 0x66, 0x00,
	0x06, 0x33, 0x33, 0x66, 0x33, 0x3C, 0x33, 0x3B, 0x0C, 0x03, 0x36, 0x0C, 0x7F, 0x33, 0x33, 0x33,	0x66, 0x3B, 0x30, 0x18, 0x33, 0x33, 0x6B, 0x36, 0x33, 0x26, 0x38, 0x0C, 0x07, 0x00, 0x19, 0x80,
	0x3C, 0x3E, 0x1E, 0x3E, 0x1E, 0x18, 0x1F, 0x36,	0x1C, 0x07, 0x33, 0x0C, 0x36, 0x6E, 0x1E, 0x6E, 0x3B, 0x6E, 0x1E, 0x3E, 0x33, 0x33, 0x63, 0x63, 0x33, 0x3F, 0x0C, 0x0C, 0x0C, 0x00, 0x66, 0x00,
	0x00, 0x30, 0x00, 0x06, 0x00, 0x1B, 0x00, 0x30, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x6E, 0x19, 0x80,
	0x00, 0x70, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x70, 0x0C, 0x03, 0x70, 0x1C, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x38, 0x3B, 0x66, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80,
	0x33, 0x7E, 0x1E, 0x7C, 0x7F, 0x78, 0x1F, 0x33, 0x3F, 0x3C, 0x73, 0x7F, 0x63, 0x63, 0x1C, 0x78, 0x3B, 0x73, 0x1E, 0x1E, 0x1E, 0x0C, 0x63, 0x63, 0x1E, 0x7F, 0x1E, 0x01, 0x1E, 0x0C, 0x00, 0x00,
	0x33, 0x33, 0x33, 0x36, 0x31, 0x30, 0x33, 0x33, 0x0C, 0x66, 0x33, 0x33, 0x63, 0x63, 0x36, 0x30, 0x66, 0x33, 0x33, 0x0C, 0x33, 0x1E, 0x77, 0x63, 0x0C, 0x33, 0x18, 0x03, 0x06, 0x0C, 0x00, 0x00,
	0x3F, 0x33, 0x60, 0x33, 0x34, 0x34, 0x67, 0x33, 0x0C, 0x66, 0x36, 0x31, 0x6B, 0x67, 0x63, 0x30, 0x6D, 0x36, 0x03, 0x0C, 0x33, 0x33, 0x7F, 0x36, 0x0C, 0x19, 0x18, 0x06, 0x06, 0x0C, 0x00, 0x00,
	0x33, 0x3E, 0x60, 0x33, 0x3C, 0x3C, 0x60, 0x3F, 0x0C, 0x06, 0x3C, 0x30, 0x7F, 0x6F, 0x63, 0x3E, 0x63, 0x3E, 0x1E, 0x0C, 0x33, 0x33, 0x6B, 0x1C, 0x1E, 0x0C, 0x18, 0x0C, 0x06, 0x0C, 0x00, 0x00,
	0x33, 0x33, 0x60, 0x33, 0x34, 0x34, 0x60, 0x33, 0x0C, 0x06, 0x36, 0x30, 0x7F, 0x7B, 0x63, 0x33, 0x63, 0x33, 0x30, 0x0C, 0x33, 0x33, 0x63, 0x1C, 0x33, 0x46, 0x18, 0x18, 0x06, 0x3F, 0x00, 0x06,
	0x1E, 0x33, 0x33, 0x36, 0x31, 0x31, 0x33, 0x33, 0x0C, 0x06, 0x33, 0x30, 0x77, 0x73, 0x36, 0x33, 0x36, 0x33, 0x33, 0x2D, 0x33, 0x33, 0x63, 0x36, 0x33, 0x63, 0x18, 0x30, 0x06, 0x1E, 0x00, 0x0C,
	0x0C, 0x7E, 0x1E, 0x7C, 0x7F, 0x7F, 0x1E, 0x33, 0x3F, 0x0F, 0x73, 0x78, 0x63, 0x63, 0x1C, 0x7E, 0x1C, 0x7E, 0x1E, 0x3F, 0x33, 0x33, 0x63, 0x63, 0x33, 0x7F, 0x1E, 0x60, 0x1E, 0x0C, 0x00, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x36, 0x0C, 0x63, 0x3B, 0x00, 0x06, 0x18, 0x00, 0x00, 0x0C, 0x00, 0x0C, 0x40, 0x3E, 0x3F, 0x3F, 0x1E, 0x0F, 0x1E, 0x1E, 0x0C, 0x1E, 0x1E, 0x0C, 0x0C, 0x06, 0x00, 0x30, 0x0C, 0x3E,
	0x00, 0x00, 0x36, 0x3E, 0x33, 0x66, 0x00, 0x0C, 0x0C, 0x33, 0x0C, 0x0C, 0x00, 0x0C, 0x60, 0x63, 0x0C, 0x33, 0x33, 0x06, 0x33, 0x33, 0x0C, 0x33, 0x33, 0x0C, 0x0C, 0x0C, 0x3F, 0x18, 0x00, 0x60,
	0x0C, 0x00, 0x7F, 0x0D, 0x18, 0x6E, 0x00, 0x18, 0x06, 0x1E, 0x0C, 0x00, 0x00, 0x00, 0x30, 0x73, 0x0C, 0x30, 0x03, 0x7F, 0x03, 0x33, 0x0C, 0x33, 0x03, 0x00, 0x00, 0x18, 0x00, 0x0C, 0x0C, 0x6F,
	0x0C, 0x00, 0x36, 0x1E, 0x0C, 0x3B, 0x00, 0x18, 0x06, 0x7F, 0xBF, 0x00, 0x3F, 0x00, 0x18, 0x6B, 0x0C, 0x1E, 0x0E, 0x66, 0x3E, 0x3E, 0x06, 0x1E, 0x1F, 0x0C, 0x0C, 0x30, 0x00, 0x06, 0x06, 0x6F,
	0x0C, 0x36, 0x7F, 0x2C, 0x66, 0x1C, 0x18, 0x18, 0x06, 0x1E, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x67, 0x0C, 0x03, 0x03, 0x36, 0x30, 0x30, 0x03, 0x33, 0x33, 0x0C, 0x0C, 0x18, 0x3F, 0x0C, 0x33, 0x6F,
	0x0C, 0x36, 0x36, 0x1F, 0x63, 0x36, 0x0C, 0x0C, 0x0C, 0x33, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x63, 0x1C, 0x33, 0x33, 0x1E, 0x31, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x0C, 0x00, 0x18, 0x33, 0x63,
	0x0C, 0x36, 0x36, 0x0C, 0x00, 0x1C, 0x0C, 0x06, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x0C, 0x1E, 0x1E, 0x0E, 0x3F, 0x1E, 0x3F, 0x1E, 0x1E, 0x00, 0x00, 0x06, 0x00, 0x30, 0x1E, 0x3E
};

typedef struct
{
	char cpcChara;
	u8 posBitmap;
} SCharMapping;

static const char charaMapBitmap[] = "!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~";

static int wincpct_findCharaIndex(char pChara)
{
	for (int i = 0; i < sizeof(charaMapBitmap); i++)
	{
		if (charaMapBitmap[i] == pChara)
			return i;
	}
	return 0;
}

static u8* wincpct_getCharacterSprite(char pChara)
{
	int index = wincpct_findCharaIndex(pChara);
	int fontx = (index % FONT_NB_LINE);
	int fonty = (FONT_NB_COL - index / FONT_NB_LINE) * FONT_SIZE - 1;

	return (sFonts + fonty * FONT_NB_LINE + fontx);
}

static void wincpct_displayFontM0(u8* video, u8 fgPen, u8 bgPen, char pChara)
{
	const u8* pixChara = wincpct_getCharacterSprite(pChara);

	u16 videoAddress = wincpct_getCpcMemAddress(video);

	/** 2 pixels per Byte -> 4 Bytes */
	for (int yi = 0; yi < FONT_SIZE; yi++)
	{
		u8* video = wincpct_getPCMemPtr(videoAddress);
		u8 val = *pixChara;

		if (pChara != ' ')
		{
			/* Input character on 1 bpp : 32 10 32 10 */

			/* 32 -> 3333 2222 */
			u8 pix3 = ((val & 0b00000001) << 0) == 0 ? cpctm_px2byteM0(0, bgPen) : cpctm_px2byteM0(0, fgPen);
			pix3 |= ((val &   0b00000010) << 1) == 0 ? cpctm_px2byteM0(bgPen, 0) : cpctm_px2byteM0(fgPen, 0);

			u8 pix2 = ((val & 0b00000100) << 2) == 0 ? cpctm_px2byteM0(0, bgPen) : cpctm_px2byteM0(0, fgPen);
			pix2 |= ((val &   0b00001000) << 3) == 0 ? cpctm_px2byteM0(bgPen, 0) : cpctm_px2byteM0(fgPen, 0);

			/* 10 -> 1111 0000 */
			u8 pix1 = ((val & 0b00010000) >> 4) == 0 ? cpctm_px2byteM0(0, bgPen) : cpctm_px2byteM0(0, fgPen);
			pix1 |= ((val &   0b00100000) >> 3) == 0 ? cpctm_px2byteM0(bgPen, 0) : cpctm_px2byteM0(fgPen, 0);

			u8 pix0 = ((val & 0b01000000) >> 2) == 0 ? cpctm_px2byteM0(0, bgPen) : cpctm_px2byteM0(0, fgPen);
			pix0 |= ((val &   0b10000000) >> 1) == 0 ? cpctm_px2byteM0(bgPen, 0) : cpctm_px2byteM0(fgPen, 0);

			*video++ = pix0;
			*video++ = pix1;
			*video++ = pix2;
			*video++ = pix3;
		}
		else
		{
			*video++ = cpctm_px2byteM0(bgPen, bgPen);
			*video++ = cpctm_px2byteM0(bgPen, bgPen);
			*video++ = cpctm_px2byteM0(bgPen, bgPen);
			*video++ = cpctm_px2byteM0(bgPen, bgPen);
		}
		
		pixChara -= FONT_NB_LINE;

		videoAddress += 4;
		wincpct_computeCrossBoundary(&videoAddress, 4);
	}

	wincpct_msgLoop();
}

static void wincpct_displayFontM1(u8* video, u8 fgPen, u8 bgPen, char pChara)
{
	const u8* pixChara = wincpct_getCharacterSprite(pChara);

	u16 videoAddress = wincpct_getCpcMemAddress(video);

	/** 4 pixels per Byte -> 2 Bytes */
	for (int yi = 0; yi < FONT_SIZE; yi++)
	{
		u8* video = wincpct_getPCMemPtr(videoAddress);
		u8 val = *pixChara;

		if (pChara != ' ')
		{
			/* Input character on 1 bpp : 3210 3210 */
			/* 3210 -> 33 22 11 00 */
			u8 pix00a = ((val & 0b00000001) << 0) == 0 ? cpctm_px2byteM1(0, 0, 0, bgPen) : cpctm_px2byteM1(0, 0, 0, fgPen);
			u8 pix11a = ((val & 0b00000010) << 1) == 0 ? cpctm_px2byteM1(0, 0, bgPen, 0) : cpctm_px2byteM1(0, 0, fgPen, 0);
			u8 pix22a = ((val & 0b00000100) << 2) == 0 ? cpctm_px2byteM1(0, bgPen, 0, 0) : cpctm_px2byteM1(0, fgPen, 0, 0);
			u8 pix33a = ((val & 0b00001000) << 3) == 0 ? cpctm_px2byteM1(bgPen, 0, 0, 0) : cpctm_px2byteM1(fgPen, 0, 0, 0);

			/* 3210 -> 33 22 11 00 */
			u8 pix00b = ((val & 0b00010000) >> 4) == 0 ? cpctm_px2byteM1(0, 0, 0, bgPen) : cpctm_px2byteM1(0, 0, 0, fgPen);
			u8 pix11b = ((val & 0b00100000) >> 3) == 0 ? cpctm_px2byteM1(0, 0, bgPen, 0) : cpctm_px2byteM1(0, 0, fgPen, 0);
			u8 pix22b = ((val & 0b01000000) >> 2) == 0 ? cpctm_px2byteM1(0, bgPen, 0, 0) : cpctm_px2byteM1(0, fgPen, 0, 0);
			u8 pix33b = ((val & 0b10000000) >> 1) == 0 ? cpctm_px2byteM1(bgPen, 0, 0, 0) : cpctm_px2byteM1(fgPen, 0, 0, 0);

			*video++ = pix33b | pix22b | pix11b | pix00b;
			*video++ = pix33a | pix22a | pix11a | pix00a;
		}
		else
		{
			*video++ = cpctm_px2byteM1(bgPen, bgPen, bgPen, bgPen);
			*video++ = cpctm_px2byteM1(bgPen, bgPen, bgPen, bgPen);
		}


		pixChara -= FONT_NB_LINE;
		videoAddress += 2;
		wincpct_computeCrossBoundary(&videoAddress, 2);
	}

	wincpct_msgLoop();
}

static void wincpct_displayFontM2(u8* video, u8 fgPen, u8 bgPen, char pChara)
{
	const u8* pixChara = wincpct_getCharacterSprite(pChara);

	u16 videoAddress = wincpct_getCpcMemAddress(video);

	/** 8 pixels per Byte */
	for (int yi = 0; yi < FONT_SIZE; yi++)
	{
		u8* video = wincpct_getPCMemPtr(videoAddress);
		u8 val = *pixChara;

		if (pChara != ' ')
		{
			u8 pen = fgPen;
			u8 back = bgPen;

			u8 pix0 = ((val & 0b00000001) == 0) ? back << 0 : pen << 0;
			pix0 |= ((val & 0b00000010) == 0) ? back << 1 : pen << 1;
			pix0 |= ((val & 0b00000100) == 0) ? back << 2 : pen << 2;
			pix0 |= ((val & 0b00001000) == 0) ? back << 3 : pen << 3;
			pix0 |= ((val & 0b00010000) == 0) ? back << 4 : pen << 4;
			pix0 |= ((val & 0b00100000) == 0) ? back << 5 : pen << 5;
			pix0 |= ((val & 0b01000000) == 0) ? back << 6 : pen << 6;
			pix0 |= ((val & 0b10000000) == 0) ? back << 7 : pen << 7;

			*video++ = pix0;
		}
		else
			*video++ = (bgPen == 1) ? 0xFF : 0x00;

		pixChara -= FONT_NB_LINE;
		videoAddress++;
		wincpct_computeCrossBoundary(&videoAddress, 1);
	}

	wincpct_msgLoop();
}

static void wincpct_drawString(void* string, void* video_memory, u8 fg_pen, u8 bg_pen, int pMode)
{
	uintptr_t offsetRam = (uintptr_t)video_memory - (uintptr_t)wincpct_getVideoArea((uintptr_t)video_memory);

	video_memory = wincpct_getMemory(video_memory);

	u8* str = (u8*)string;
	u8* video = (u8*)video_memory;
	int videoOffset = 0;

	for (u8 i = 0; i < strlen(str); i++)
	{
		switch (pMode)
		{
		case MODE_0: wincpct_displayFontM0(video + videoOffset, fg_pen, bg_pen, str[i]);
			break;
		case MODE_1: wincpct_displayFontM1(video + videoOffset, fg_pen, bg_pen, str[i]);
			break;
		case MODE_2: wincpct_displayFontM2(video + videoOffset, fg_pen, bg_pen, str[i]);
			break;
		}

		switch (pMode)
		{
		case MODE_0: videoOffset += 4; break;
		case MODE_1: videoOffset += 2; break;
		case MODE_2: videoOffset += 1; break;
		}

		/** Test if character end of line */
		if (videoOffset > 0 && (offsetRam + videoOffset) % 80 == 0)
			videoOffset += 8 * 80;
	}

	wincpct_msgLoop();
}

/** CPCTelera API */
/** Updated for v1.5*/
static u8 fg_pen_mode, bg_pen_mode = 1;

/** Mode 0 */
void cpct_setDrawCharM0(u8 fg_pen, u8 bg_pen)
{
	fg_pen_mode = fg_pen;
	bg_pen_mode = bg_pen;
}

void cpct_drawCharM0(void* video_memory, u16 ascii)
{
	if (wincpct_isCpcMem(video_memory))
		video_memory = wincpct_getMemory(video_memory);

	wincpct_displayFontM0(video_memory, fg_pen_mode, bg_pen_mode, (char)ascii);
}

void cpct_drawStringM0(const char* string, void* video_memory)
{
	wincpct_drawString(string, video_memory, fg_pen_mode, bg_pen_mode, MODE_0);
}

/** Mode 1 */
void cpct_setDrawCharM1(u8 fg_pen, u8 bg_pen)
{
	fg_pen_mode = fg_pen;
	bg_pen_mode = bg_pen;
}

void cpct_drawCharM1(void* video_memory, u16 ascii)
{
	video_memory = wincpct_getMemory(video_memory);
	wincpct_displayFontM1(video_memory, fg_pen_mode, bg_pen_mode, (char)ascii);
}

void cpct_drawCharM1_f(void* video_memory, u8 fg_pen, u8 bg_pen, u8 ascii)
{
	cpct_setDrawCharM1(fg_pen, bg_pen);
	cpct_drawCharM1(video_memory, ascii);
}

void cpct_drawStringM1(const char* string, void* video_memory)
{
	wincpct_drawString(string, video_memory, fg_pen_mode, bg_pen_mode, MODE_1);
}

void cpct_drawStringM1_f(const char* string, void* video_memory, u8 fg_pen, u8 bg_pen)
{
	wincpct_drawString(string, video_memory, fg_pen, bg_pen, MODE_1);
}

/** Mode 2 */
void cpct_setDrawCharM2(u8 fg_pen, u8 bg_pen)
{
	fg_pen_mode = fg_pen;
	bg_pen_mode = bg_pen;
}

void cpct_drawCharM2(void* video_memory, u16 ascii)
{
	video_memory = wincpct_getVideoBufferFromAddress(video_memory);
	wincpct_displayFontM2(video_memory, fg_pen_mode, bg_pen_mode, (char)ascii);
}

void cpct_drawStringM2(const char* string, void* video_memory)
{
	wincpct_drawString(string, video_memory, fg_pen_mode, bg_pen_mode, MODE_2);
}

#undef FONT_SIZE
#undef FONT_NB_LINE
#undef FONT_NB_COL
#undef FONT_COL